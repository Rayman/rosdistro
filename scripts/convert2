#!/usr/bin/env python
from __future__ import print_function

import logging
import logging.config
import os
import os
from argparse import ArgumentParser
from collections import namedtuple
from copy import deepcopy
from pprint import pformat

import yaml
from colorlog import ColoredFormatter
from tqdm import tqdm


class TqdmHandler(logging.StreamHandler):
    def __init__(self):
        logging.StreamHandler.__init__(self)

    def emit(self, record):
        msg = self.format(record)
        tqdm.write(msg)


logging.config.dictConfig({
    'version': 1,
    'disable_existing_loggers': False,
    'loggers': {
        'vcstool.executor': {
            'level': 'INFO',
        }
    },
    'root': {
        'level': 'INFO',
    },
})

formatter = ColoredFormatter("%(log_color)s[%(levelname).4s] %(message)s")
console = TqdmHandler()
console.setFormatter(formatter)
logging.getLogger().addHandler(console)

logger = logging.getLogger(__name__)


class Target(object):
    def __repr__(self):
        return "%s(%s)" % (self.__class__.__name__, pformat(self.__dict__))


class MetaPackage(Target):
    def __init__(self, dependencies):
        self.dependencies = dependencies


class Package(Target):
    def __init__(self, type, url, version, subdir):
        self.type = type
        self.url = url
        self.version = version
        self.subdir = subdir


class ROSSystem(Target):
    def __init__(self, name):
        self.name = name


class System(Target):
    def __init__(self, name):
        self.name = name


class Pip(Target):
    def __init__(self, name):
        self.name = name


class Redirect(Target):
    def __init__(self, name):
        self.name = name


def parse_target(path):
    basename = os.path.basename(path)
    logger.debug("parsing '%s'", basename)

    ret = None
    try:
        with open(os.path.join(path, 'install.yaml')) as f:
            target = yaml.load(f)
            ret = parse_target_yaml(target)
    except IOError:
        pass
    try:
        with open(os.path.join(path, 'install.bash')) as f:
            if ret:
                logger.warn("also install.bash found for '%s'", basename)
                return ret
            else:
                return parse_target_bash(f.read())
    except IOError:
        if ret:
            return ret
        else:
            logger.debug('install.bash not found')

    logger.warn("no target found for '%s'", basename)
    return None


def parse_target_bash(f):
    lines = f.splitlines()
    if len(lines) == 1:
        logger.warn('unknown setup.bash')
    else:
        logger.info("complex install.bash found")
    return None


def parse_target_yaml(target):
    if len(target) == 1:
        return parse_single_target(target[0])
    else:
        return parse_meta_target(target)


def parse_single_target(target):
    target = target.copy()
    tt = target.pop('type')

    if tt == 'ros':
        return parse_ros_target(**target)
    elif tt == 'system':
        return parse_system_target(**target)
    elif tt == 'target':
        return parse_redirect_target(**target)
    elif tt == 'ros-rosbuild':
        logger.error('rosbuild target')
    elif tt == 'pip':
        return parse_pip_target(**target)
    else:
        logger.error('unknown target type: %s' % tt)


def parse_ros_target(source, **kwargs):
    assert not kwargs, "Unexpected kwargs: %s" % kwargs

    source = source.copy()
    tt = source.pop('type')

    # remove dash in sub-dir
    if 'sub-dir' in source:
        source['subdir'] = source.pop('sub-dir')

    if tt == 'git':
        return parse_source(tt, **source)
    elif tt == 'system':
        return parse_ros_system(**source)
    else:
        assert False, tt


def parse_system_target(name, **kwargs):
    assert not kwargs, "Unexpected kwargs: %s" % kwargs

    return System(name)


def parse_redirect_target(name, **kwargs):
    assert not kwargs, "Unexpected kwargs: %s" % kwargs

    return Redirect(name)


def parse_pip_target(name, **kwargs):
    assert not kwargs, "Unexpected kwargs: %s" % kwargs

    return Pip(name)


def parse_meta_target(targets):
    deps = []
    for target in targets:
        dep = parse_single_target(target)
        if isinstance(dep, Redirect):
            deps.append(dep.name)
        elif isinstance(dep, System):
            deps.append(dep.name)
        else:
            logger.error('unexpected target found in metatarget: %s', target)
    return MetaPackage(deps)


def parse_source(type, url, version='master', subdir=None, **kwargs):
    assert not kwargs, "Unexpected kwargs: %s" % kwargs

    return Package(type, url, version, subdir)


def parse_ros_system(name, **kwargs):
    assert not kwargs, "Unexpected kwargs: %s" % kwargs

    return ROSSystem(name)


if __name__ == '__main__':
    parser = ArgumentParser()
    parser.add_argument('-v', '--verbose', action='store_true')
    args = parser.parse_args()

    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)

    data_path = os.path.join(os.path.dirname(__file__), '..', 'data', 'tue-env')
    target_path = os.path.join(data_path, 'installer', 'targets')

    targets = (os.path.join(target_path, o) for o in os.listdir(target_path))
    targets = [t for t in targets if os.path.isdir(t)]

    mps = []
    rosdeps = []
    pkgs = []
    for target in tqdm(targets):
        t = parse_target(target)
        if isinstance(t, MetaPackage):
            mps.append(t)
        elif isinstance(t, Package):
            pkgs.append(t)
        elif isinstance(t, System):
            rosdeps.append(t)
        elif isinstance(t, ROSSystem):
            rosdeps.append(t)
        elif isinstance(t, Pip):
            rosdeps.append(t)
        elif isinstance(t, Redirect):
            logger.warn("'%s'", t)
        elif t is None:
            pass
        else:
            assert False, t

    for p in pkgs:
        print(p)
